#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Thu Feb  8 20:18:03 2018

@author: keithstaylor
"""



import numpy as np
import numpy.fft as fft
import matplotlib.pyplot as pl
import matplotlib.mlab as mlab
from scipy import fftpack as fftp
from scipy import interpolate

"""
Coloured noise generator


Program to take signal in time domain from *.txt file in same directory and
apply noise. Output is a .txt file in time domain. 
Input signal should contain time and signal amplitudes in same file.
Program assumes that the file H1-PSD.txt is in same directory as 
coloured-noise-generator.py, this is generated by noise-psd-ligoH1-GW150914
"""

#load noise psd
ligo_psd = np.loadtxt('H1-PSD.txt')
nf = ligo_psd[0, :]
xf_n = 1e23*np.sqrt(ligo_psd[1, :])

# load signal from *.txt file, checking user input
filename = input('Enter file name (including \".txt\"): ')
while 1:
    try:
        signal = np.loadtxt(filename)
        break
    except FileNotFoundError:
        filename = input('File not found, please try again... ')

t = signal[0, :]
h = signal[1, :]

N = len(h)
Ts = t[1]-t[0]

xf_h = fft.rfftfreq(N, Ts)
hf = fft.rfft(h)  # convert signal to freq domain


#load noise and and scale to signal, also randomise phase
ligo_psd = np.loadtxt('H1-PSD.txt')
xf_n = ligo_psd[1, :]
nf = 1e22*max(abs(hf))*np.sqrt(ligo_psd[0, :])*np.exp(2j*np.pi*np.random.rand())


# ensure both have same length in the frequency domain
if len(hf) < len(nf):
    hf = np.interp(xf_n, xf_h, hf)
    xf = xf_n
elif len(hf) > len(nf):
    nf = np.interp(xf_h, xf_n, nf)
    xf = xf_h


# combine noise and signal and convert back to time domain
df = hf+nf  
d = fft.irfft(df)



#%%
'''random noise generator'''
noise = np.random.normal(m,sd,N) #Gaussian Noise 
ny = h + noise #noisy signal 


'''ASD'''
#coloured noise
NFFT = len(ny)
Pxx_gaussian, freqs = mlab.psd(ny, NFFT = int(NFFT), Fs = Fs, window=mlab.window_hanning)
PSD_gaussian = interpolate.interp1d(freqs, Pxx_gaussian)

#random noise
Pxx_coloured, freqs = mlab.psd(??, NFFT = int(NFFT), Fs = Fs, window=mlab.window_hanning)
PSD_coloured = interpolate.interp1d(freqs, Pxx_coloured)

#plot sine wave 
pl.figure(1) 
pl.title('Sine Wave')
pl.plot(t,y, label='Provisional Sine wave signal')
pl.xlabel('Time (s)')
pl.ylabel('Amplitude')
pl.grid()

pl.figure(2)
#plot gaussian noisy signal
pl.subplot(211)
pl.title('Sine Wave + gaussian noise')
pl.plot(t, ny, label='Noisy Signal')
pl.xlabel('Time (s)')
pl.ylabel('Amplitude')
pl.grid()

pl.subplot(212)
pl.title('Sine Wave + coloured noise')
pl.plot(t, ??, label='Noisy Signal')
pl.xlabel('Time (s)')
pl.ylabel('Amplitude')
pl.grid()

pl.figure(3)

pl.subplot(211)
pl.loglog(freqs, np.sqrt(Pxx_guassian))
pl.title('ASD, gaussian noise')
pl.xlabel('Freq (Hz)')
pl.ylabel('ASD (strain)')
pl.grid()

pl.subplot(212)
pl.loglog(freqs, np.sqrt(Pxx_coloured))
pl.title('ASD, coloured LIGO noise')
pl.xlabel('Freq (Hz)')
pl.ylabel('ASD (strain)')
pl.grid()

pl.show

'''Whitening  - transform to freq domain, divide by asd, transform back'''

#gaussian
# xf_h = np.fft.rfftfreq(N, Ts)
df_2g = fftp.fft(ny) #2 sided fft
df_1g = df_2g[0:(N//2)+1] #1 sided fft

#ensure both have same length in the frequency domain

white_ny = df_1g/ np.sqrt(Pxx_gaussian)

white_nyback = np.fft.irfft(white_ny)

white_nyback1 = white_nyback[0:N]

#coloured
df_2c = fftp.fft(??) #2 sided fft
df_1c = df_2c[0:(N//2)+1] #1 sided fft

#ensure both have same length in the frequency domain

white_c = df_1g/ np.sqrt(Pxx_gaussian)

white_cback = np.fft.irfft(white_c)

white_cback1 = white_cback[0:N]





pl.figure(5)
pl.subplot(211)
pl.title('Whitened Gaussian Signal')
pl.plot(t,white_nyback, label='Whitened Signal')
pl.xlabel('Time (s)')
pl.ylabel('Amplitude')
pl.grid()

pl.subplot(212)
pl.title('Whitened Coloured Signal')
pl.plot(t,white_cback, label='Whitened Signal')
pl.xlabel('Time (s)')
pl.ylabel('Amplitude')
pl.grid()


pl.show()
